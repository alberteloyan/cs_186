package simpledb;

import java.util.*;

/**
 * The Join operator implements the relational join operation.
 */
public class Join extends Operator {
        
        /**
         * The predicate to use to join the children
         */
        private JoinPredicate p;
                
        /**
         * Iterator for the left(outer) relation to join
         */
        private DbIterator child1;
        
        /**
         * Iterator for the right(inner) relation to join
         */
        private DbIterator child2;
        
        /* 
         * variables required for the fetchNext() method
         */
        
        // keeps track if more tuples exist in the outer relation
        private boolean moreOuterTuplesExist = true;
        
        // keeps track if next tuple of outer relation needs to be read
        private boolean getNextOuterTuple = true;
                
        // stores the current tuple of the outer relation for the nested loop join
        private Tuple outerTuple = null;
        
        // Hashmap for hash-join
        private Map<Field, List<Tuple>> hashJoinMap;
        
        
    private static final long serialVersionUID = 1L;
    /**
     * Constructor. Accepts to children to join and the predicate to join them
     * on
     * 
     * @param p
     *            The predicate to use to join the children
     * @param child1
     *            Iterator for the left(outer) relation to join
     * @param child2
     *            Iterator for the right(inner) relation to join
     */
    public Join(JoinPredicate p, DbIterator child1, DbIterator child2) {
        this.p = p;
        this.child1 = child1;
        this.child2 = child2;

    }

    public JoinPredicate getJoinPredicate() {
        return p;
    }

    /**
     * @return
     *       the field name of join field1. Should be quantified by
     *       alias or table name.
     * */
    public String getJoinField1Name() {
        
        String fieldName = child1.getTupleDesc().getFieldName(p.getField1());
        return fieldName;
        
    }

    /**
     * @return
     *       the field name of join field2. Should be quantified by
     *       alias or table name.
     * */
    public String getJoinField2Name() {
        
        String fieldName = child2.getTupleDesc().getFieldName(p.getField1());
        return fieldName;
    }

    /**
     * @see simpledb.TupleDesc#merge(TupleDesc, TupleDesc) for possible
     *      implementation logic.
     */
    public TupleDesc getTupleDesc() {
        TupleDesc child1TD = child1.getTupleDesc();
        TupleDesc child2TD = child2.getTupleDesc();
        TupleDesc joinedTD = TupleDesc.merge(child1TD, child2TD);
        return joinedTD;
    }

    public void open() throws DbException, NoSuchElementException,
            TransactionAbortedException {
            super.open();
        child1.open();
        child2.open();
        
    }

    public void close() {
    super.close();
        child1.close();
        child2.close();
    }

    public void rewind() throws DbException, TransactionAbortedException {
        child1.rewind();
        child2.rewind();
    }

    /**
     * Returns the next tuple generated by the join, or null if there are no
     * more tuples. Logically, this is the next tuple in r1 cross r2 that
     * satisfies the join predicate. There are many possible implementations;
     * the simplest is a nested loops join.
     * <p>
     * Note that the tuples returned from this particular implementation of Join
     * are simply the concatenation of joining tuples from the left and right
     * relation. Therefore, if an equality predicate is used there will be two
     * copies of the join attribute in the results. (Removing such duplicate
     * columns can be done with an additional projection operator if needed.)
     * <p>
     * For example, if one tuple is {1,2,3} and the other tuple is {1,5,6},
     * joined on equality of the first column, then this returns {1,2,3,1,5,6}.
     * 
     * @return The next matching tuple.
     * @see JoinPredicate#filter
     */
    protected Tuple fetchNext() throws TransactionAbortedException, DbException {
    
       
        // check if more outer tuples exist before iteration over outer relation
        if(getNextOuterTuple) {
                moreOuterTuplesExist = child1.hasNext();
        }
        
        while(moreOuterTuplesExist){
                if(getNextOuterTuple){
                        outerTuple = child1.next();
                }
                        
                while(child2.hasNext()){
                        
                        Tuple innerTuple = child2.next();
                                                
                        if(p.filter(outerTuple, innerTuple)){
                                // join predicate match
                                
                                // still iterating over inner relation tuples, 
                                // so do not get next outer relation tuple
                                getNextOuterTuple = false;
                                
                                // create a new joined tuple
                                Tuple joinedTuple = new Tuple(this.getTupleDesc());
                                int index = 0;
                                
                                // fill joined tuple with contents of outer tuple and then inner tuple
                                for(int i = 0; i < outerTuple.getTupleDesc().numFields(); i ++){
                                        joinedTuple.setField(i, outerTuple.getField(i));
                                        index++;
                                }
                                for(int j = index; j < joinedTuple.getTupleDesc().numFields(); j++){
                                        joinedTuple.setField(j, innerTuple.getField(j-index));
                                }
                                
                                return joinedTuple;
                        }
                }
                // finished iterating over all tuples in inner relation, so...
                
                // reset to get first tuple of inner relation, and
                child2.rewind();
                
                // try to get next outer relation tuple
                getNextOuterTuple = true;
                moreOuterTuplesExist = child1.hasNext();
                
        }
        return null;
                
    }
    
    

    @Override
    public DbIterator[] getChildren() {
        return new DbIterator[] { this.child1, this.child2 };
    }

    @Override
    public void setChildren(DbIterator[] children) {
        this.child1 = children[0];
        this.child2 = children[1];
    }

}
